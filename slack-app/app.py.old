# slack-app/config.py
import os
import logging

class Config:
    """Application configuration"""
    
    # Slack Configuration
    SLACK_APP_TOKEN = os.environ.get("SLACK_APP_TOKEN")
    SLACK_BOT_TOKEN = os.environ.get("SLACK_BOT_TOKEN")
    
    # LLM Configuration
    LLM_API_ENDPOINT = os.environ.get("LLM_API_ENDPOINT")
    LLM_API_KEY = os.environ.get("LLM_API_KEY")
    
    # RAG Configuration
    RAG_ENABLED = os.environ.get("RAG_ENABLED", "true").lower() == "true"
    CHROMADB_HOST = os.environ.get("CHROMADB_HOST", "chromadb-service.bot-infra.svc.cluster.local")
    CHROMADB_PORT = int(os.environ.get("CHROMADB_PORT", "8000"))
    
    # Application Configuration
    MAX_HISTORY_MESSAGES = int(os.environ.get("MAX_HISTORY_MESSAGES", "3"))
    MAX_MESSAGE_LENGTH = int(os.environ.get("MAX_MESSAGE_LENGTH", "4000"))
    LLM_TIMEOUT = int(os.environ.get("LLM_TIMEOUT", "45"))
    MAX_TOKENS = int(os.environ.get("MAX_TOKENS", "300"))
    HEALTH_CHECK_PORT = int(os.environ.get("HEALTH_CHECK_PORT", "8080"))
    
    # Logging Configuration
    LOG_LEVEL = os.environ.get("LOG_LEVEL", "INFO")
    
    @classmethod
    def validate(cls):
        """Validate required configuration"""
        required = [
            cls.SLACK_APP_TOKEN,
            cls.SLACK_BOT_TOKEN, 
            cls.LLM_API_ENDPOINT
        ]
        
        missing = [name for name, value in [
            ("SLACK_APP_TOKEN", cls.SLACK_APP_TOKEN),
            ("SLACK_BOT_TOKEN", cls.SLACK_BOT_TOKEN),
            ("LLM_API_ENDPOINT", cls.LLM_API_ENDPOINT)
        ] if not value]
        
        if missing:
            raise ValueError(f"Missing required environment variables: {', '.join(missing)}")
        
        return True


# slack-app/health.py
import json
import logging
from http.server import HTTPServer, BaseHTTPRequestHandler
from threading import Thread
from typing import Optional

logger = logging.getLogger(__name__)

class HealthCheckHandler(BaseHTTPRequestHandler):
    """HTTP handler for health checks"""
    
    def __init__(self, health_checker, *args, **kwargs):
        self.health_checker = health_checker
        super().__init__(*args, **kwargs)
    
    def do_GET(self):
        """Handle GET requests"""
        if self.path == "/health" or self.path == "/":
            self._handle_health()
        elif self.path == "/ready":
            self._handle_readiness()
        else:
            self._send_response(404, {"error": "Not found"})
    
    def _handle_health(self):
        """Handle health check requests"""
        try:
            status = self.health_checker.get_health()
            code = 200 if status["status"] == "healthy" else 503
            self._send_response(code, status)
        except Exception as e:
            logger.error(f"Health check error: {e}")
            self._send_response(503, {"status": "unhealthy", "error": str(e)})
    
    def _handle_readiness(self):
        """Handle readiness check requests"""
        try:
            status = self.health_checker.get_readiness()
            code = 200 if status["ready"] else 503
            self._send_response(code, status)
        except Exception as e:
            logger.error(f"Readiness check error: {e}")
            self._send_response(503, {"ready": False, "error": str(e)})
    
    def _send_response(self, code: int, data: dict):
        """Send JSON response"""
        self.send_response(code)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())
    
    def log_message(self, format, *args):
        """Override to use our logger"""
        logger.debug(format % args)

class HealthChecker:
    """Health check logic"""
    
    def __init__(self, message_processor=None, rag_client=None):
        self.message_processor = message_processor
        self.rag_client = rag_client
    
    def get_health(self) -> dict:
        """Get application health status"""
        status = {
            "status": "healthy",
            "timestamp": self._get_timestamp(),
            "components": {}
        }
        
        # Check message processor
        if self.message_processor:
            try:
                bot_id = getattr(self.message_processor, 'bot_user_id', None)
                status["components"]["slack"] = {
                    "status": "healthy" if bot_id else "degraded",
                    "bot_id": bot_id
                }
            except Exception as e:
                status["components"]["slack"] = {
                    "status": "unhealthy",
                    "error": str(e)
                }
                status["status"] = "unhealthy"
        
        # Check RAG system
        if self.rag_client:
            try:
                rag_healthy = self.rag_client.health_check()
                rag_stats = self.rag_client.get_collection_stats()
                status["components"]["rag"] = {
                    "status": "healthy" if rag_healthy else "unhealthy",
                    "stats": rag_stats
                }
                if not rag_healthy:
                    status["status"] = "degraded"  # RAG failure is non-critical
            except Exception as e:
                status["components"]["rag"] = {
                    "status": "unhealthy",
                    "error": str(e)
                }
                # RAG failure doesn't make the whole service unhealthy
                if status["status"] == "healthy":
                    status["status"] = "degraded"
        
        return status
    
    def get_readiness(self) -> dict:
        """Get application readiness status"""
        ready = True
        components = {}
        
        # Check if message processor is ready
        if self.message_processor:
            try:
                bot_id = getattr(self.message_processor, 'bot_user_id', None)
                components["slack"] = bool(bot_id)
                if not bot_id:
                    ready = False
            except:
                components["slack"] = False
                ready = False
        
        return {
            "ready": ready,
            "timestamp": self._get_timestamp(),
            "components": components
        }
    
    def _get_timestamp(self) -> str:
        """Get current timestamp"""
        from datetime import datetime
        return datetime.utcnow().isoformat() + "Z"

class HealthServer:
    """HTTP server for health checks"""
    
    def __init__(self, port: int, health_checker: HealthChecker):
        self.port = port
        self.health_checker = health_checker
        self.server: Optional[HTTPServer] = None
        self.thread: Optional[Thread] = None
    
    def start(self):
        """Start the health check server"""
        try:
            handler = lambda *args, **kwargs: HealthCheckHandler(self.health_checker, *args, **kwargs)
            self.server = HTTPServer(('0.0.0.0', self.port), handler)
            self.thread = Thread(target=self.server.serve_forever, daemon=True)
            self.thread.start()
            logger.info(f"Health check server started on port {self.port}")
        except Exception as e:
            logger.error(f"Failed to start health check server: {e}")
            raise
    
    def stop(self):
        """Stop the health check server"""
        if self.server:
            self.server.shutdown()
            self.server.server_close()
        if self.thread:
            self.thread.join(timeout=5)
        logger.info("Health check server stopped")


# slack-app/app.py
import logging
import os
import sys
import signal
from pathlib import Path

from concurrent.futures import ThreadPoolExecutor
from typing import List, Dict, Optional
import re
import json
import requests
import time

from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler

# Import our modules
from config import Config
from health import HealthChecker, HealthServer
from rag_module.rag_client import RAGClient

# Configure logging
logging.basicConfig(
    level=getattr(logging, Config.LOG_LEVEL),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Validate configuration
Config.validate()

# Initialize Slack app
app = App(token=Config.SLACK_BOT_TOKEN)

# Thread pool for async operations
executor = ThreadPoolExecutor(max_workers=10)

class MessageProcessor:
    """Handles message processing and context management"""
    
    def __init__(self, client: WebClient):
        self.client = client
        self.bot_user_id = None
        self._get_bot_user_id()
    
    def _get_bot_user_id(self):
        """Cache bot user ID to avoid repeated API calls"""
        try:
            response = self.client.auth_test()
            self.bot_user_id = response["user_id"]
            logger.info(f"Bot User ID: {self.bot_user_id}")
        except SlackApiError as e:
            logger.error(f"Error getting bot user ID: {e}")
            raise
    
    def get_conversation_history(self, channel_id: str, limit: int = Config.MAX_HISTORY_MESSAGES) -> List[Dict]:
        """Fetch recent messages with better error handling and filtering"""
        try:
            response = self.client.conversations_history(
                channel=channel_id,
                limit=limit * 3  # Get more to account for filtering
            )
            
            messages = response.get('messages', [])
            
            # Filter out bot messages, system messages, and empty messages
            filtered_messages = []
            for msg in messages:
                if (msg.get('type') == 'message' and 
                    'text' in msg and 
                    msg.get('user') != self.bot_user_id and
                    not msg.get('bot_id') and
                    msg.get('text', '').strip() and
                    not msg.get('subtype')):  # Exclude message edits, deletes, etc.
                    filtered_messages.append(msg)
                    
                if len(filtered_messages) >= limit:
                    break
            
            filtered_messages.reverse()  # Oldest to newest
            return filtered_messages
            
        except SlackApiError as e:
            logger.error(f"Error fetching conversation history: {e}")
            return []
    
    def clean_message_text(self, text: str) -> str:
        """Enhanced message cleaning"""
        if not text:
            return ""
        
        # Remove bot mentions
        text = re.sub(r'<@[A-Z0-9]+>', '', text)
        
        # Clean up Slack formatting
        text = re.sub(r'<#[A-Z0-9]+\|([^>]+)>', r'#\1', text)  # Channel mentions
        text = re.sub(r'<@[A-Z0-9]+\|([^>]+)>', r'@\1', text)  # User mentions with names
        text = re.sub(r'<([^>|]+)\|([^>]+)>', r'\2', text)      # Links with text
        text = re.sub(r'<([^>]+)>', r'\1', text)                # Simple links
        
        # Remove excessive whitespace
        text = re.sub(r'\s+', ' ', text).strip()
        
        return text
    
    def format_messages_for_llm(self, messages: List[Dict], current_query: str) -> List[Dict]:
        """Create optimized prompt with better context management"""
        formatted_messages = []
        
        # Add system message for technical context
        system_prompt = {
            "role": "system",
            "content": ("You are a helpful technical assistant in a Slack workspace. "
                       "Provide concise, accurate answers focused on the specific question. "
                       "If you don't know something, say so clearly. "
                       "Keep responses under 2000 characters when possible. "
                       "Format code with backticks for readability.")
        }
        formatted_messages.append(system_prompt)
        
        # Add conversation history (limited and cleaned)
        total_chars = len(system_prompt["content"])
        
        for msg in messages:
            cleaned_text = self.clean_message_text(msg.get('text', ''))
            
            if not cleaned_text:
                continue
                
            # Limit individual message length
            if len(cleaned_text) > 500:
                cleaned_text = cleaned_text[:497] + "..."
            
            # Check total length to avoid token limits
            if total_chars + len(cleaned_text) > 2000:
                break
                
            formatted_messages.append({
                "role": "user",
                "content": cleaned_text
            })
            total_chars += len(cleaned_text)
        
        # Add current query
        current_query = self.clean_message_text(current_query)
        if current_query:
            formatted_messages.append({
                "role": "user", 
                "content": current_query
            })
        
        return formatted_messages

class LLMService:
    """Handles LLM API interactions with optimizations"""
    
    def __init__(self, endpoint: str, api_key: Optional[str] = None):
        self.endpoint = endpoint
        self.api_key = api_key
        self.session = requests.Session()
    
    def call_llm(self, messages: List[Dict], context: str = None) -> str:
        """Enhanced LLM call with optional RAG context"""
        
        # If context is provided, enhance the system message
        if context and messages:
            enhanced_system = messages[0].copy()
            enhanced_system["content"] += f"\n\nRelevant context from knowledge base:\n{context}"
            messages = [enhanced_system] + messages[1:]
        
        payload = {
            "messages": messages,
            "temperature": 0.3,
            "max_tokens": Config.MAX_TOKENS,
            "top_p": 0.9,
            "stream": False
        }
        
        headers = {
            "Content-Type": "application/json",
            "User-Agent": "SlackBot/1.0"
        }
        
        if self.api_key:
            headers["Authorization"] = f"Bearer {self.api_key}"
        
        try:
            logger.info(f"Sending LLM request with {len(messages)} messages")
            
            response = self.session.post(
                self.endpoint,
                headers=headers,
                json=payload,
                timeout=Config.LLM_TIMEOUT
            )
            
            response.raise_for_status()
            result = response.json()
            
            if (result and 'choices' in result and 
                result['choices'] and 
                'message' in result['choices'][0] and
                'content' in result['choices'][0]['message']):
                
                content = result['choices'][0]['message']['content'].strip()
                
                # Truncate if too long for Slack
                if len(content) > Config.MAX_MESSAGE_LENGTH:
                    content = content[:Config.MAX_MESSAGE_LENGTH-50] + "... [truncated]"
                
                return content
            else:
                logger.error(f"Unexpected LLM response format: {result}")
                return "I received an unexpected response format. Please try again."
                
        except requests.exceptions.Timeout:
            logger.error("LLM request timed out")
            return "The request took too long to process. Please try a simpler question."
            
        except requests.exceptions.RequestException as e:
            logger.error(f"LLM request failed: {e}")
            return "I'm having trouble connecting to my knowledge base. Please try again later."
            
        except Exception as e:
            logger.error(f"Unexpected error in LLM call: {e}")
            return "An unexpected error occurred. Please try again."

def process_llm_request(channel_id: str, user_query: str, thinking_message_ts: str = None):
    """Process LLM request in background thread with RAG integration"""
    try:
        # Get conversation history
        history = message_processor.get_conversation_history(channel_id)
        
        # Format messages for LLM
        formatted_messages = message_processor.format_messages_for_llm(history, user_query)
        
        # Try RAG retrieval if enabled
        context = None
        if Config.RAG_ENABLED and rag_client:
            try:
                search_results = rag_client.search(user_query, top_k=3)
                if search_results:
                    context_parts = []
                    for result in search_results:
                        title = result.get('title', 'Untitled')
                        content = result.get('content', '')[:500]  # Limit context length
                        url = result.get('url', '')
                        
                        context_parts.append(f"**{title}**\n{content}")
                        if url:
                            context_parts[-1] += f"\nSource: {url}"
                    
                    context = "\n\n---\n\n".join(context_parts)
                    logger.info(f"Found {len(search_results)} relevant documents for query")
            except Exception as e:
                logger.warning(f"RAG search failed, proceeding without context: {e}")
        
        # Call LLM with or without context
        llm_response = llm_service.call_llm(formatted_messages, context)
        
        # Delete the thinking message if provided
        if thinking_message_ts:
            try:
                app.client.chat_delete(
                    channel=channel_id,
                    ts=thinking_message_ts
                )
            except SlackApiError as e:
                logger.warning(f"Could not delete thinking message: {e}")
        
        # Send the actual response
        app.client.chat_postMessage(
            channel=channel_id, 
            text=llm_response
        )
            
    except Exception as e:
        logger.error(f"Error in background LLM processing: {e}")
        
        # Delete thinking message on error too
        if thinking_message_ts:
            try:
                app.client.chat_delete(
                    channel=channel_id,
                    ts=thinking_message_ts
                )
            except SlackApiError:
                pass
        
        # Send error message
        try:
            app.client.chat_postMessage(
                channel=channel_id, 
                text="I encountered an error processing your request. Please try again."
            )
        except Exception as send_error:
            logger.error(f"Failed to send error message: {send_error}")

@app.event("app_mention")
def handle_app_mention_events(event, say, ack):
    """Optimized app mention handler with async processing"""
    ack()
    
    try:
        user_query = message_processor.clean_message_text(event.get('text', ''))
        channel_id = event['channel']
        
        logger.info(f"Processing mention in channel {channel_id}: '{user_query[:100]}...'")
        
        # Validate query
        if not user_query or len(user_query.strip()) < 2:
            say("👋 Hi! I'm here to help with technical questions. Please ask me something specific!")
            return
        
        # Send thinking message and capture its timestamp
        thinking_response = say("🤔 Let me think about that...")
        thinking_ts = thinking_response.get('ts') if thinking_response else None
        
        # Process in background thread
        executor.submit(process_llm_request, channel_id, user_query, thinking_ts)
        
    except Exception as e:
        logger.error(f"Error in app mention handler: {e}")
        try:
            say("Sorry, I encountered an error. Please try again.")
        except:
            pass

@app.event("message")
def handle_direct_messages(event, say, ack):
    """Handle direct messages to the bot"""
    # Only respond to DMs, not channel messages
    if event.get('channel_type') != 'im':
        return
    
    # Don't respond to bot messages or messages without user
    if (event.get('bot_id') or 
        event.get('user') == message_processor.bot_user_id or
        not event.get('user')):
        return
    
    ack()
    
    user_query = message_processor.clean_message_text(event.get('text', ''))
    
    if not user_query or len(user_query.strip()) < 2:
        return
    
    channel_id = event['channel']
    
    logger.info(f"Processing DM: '{user_query[:100]}...'")
    
    # Send thinking message
    thinking_response = say("🤔 Processing your question...")
    thinking_ts = thinking_response.get('ts') if thinking_response else None
    
    # Process in background
    executor.submit(process_llm_request, channel_id, user_query, thinking_ts)

@app.error
def handle_errors(error):
    """Global error handler"""
    logger.error(f"Slack app error: {error}")

# Initialize services globally
message_processor = None
llm_service = None
rag_client = None
health_server = None

def signal_handler(signum, frame):
    """Handle shutdown signals"""
    logger.info("Received shutdown signal, cleaning up...")
    
    if health_server:
        health_server.stop()
    
    executor.shutdown(wait=True)
    logger.info("Shutdown complete")
    sys.exit(0)

if __name__ == "__main__":
    logger.info("Starting Slack bot with RAG integration...")
    
    # Register signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    try:
        # Initialize services
        message_processor = MessageProcessor(app.client)
        llm_service = LLMService(Config.LLM_API_ENDPOINT, Config.LLM_API_KEY)
        
        # Initialize RAG client if enabled
        if Config.RAG_ENABLED:
            try:
                rag_client = RAGClient(
                    chroma_host=Config.CHROMADB_HOST,
                    chroma_port=Config.CHROMADB_PORT
                )
                logger.info("RAG client initialized successfully")
            except Exception as e:
                logger.warning(f"RAG client initialization failed: {e}")
                logger.warning("Proceeding without RAG functionality")
                Config.RAG_ENABLED = False
        
        # Start health check server
        health_checker = HealthChecker(message_processor, rag_client)
        health_server = HealthServer(Config.HEALTH_CHECK_PORT, health_checker)
        health_server.start()
        
        # Start the Slack app
        handler = SocketModeHandler(app, Config.SLACK_APP_TOKEN)
        logger.info("🚀 Slack bot started successfully with RAG integration!")
        handler.start()
        
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.error(f"Failed to start bot: {e}")
        raise
    finally:
        if health_server:
            health_server.stop()
        executor.shutdown(wait=True)
        logger.info("Executor shutdown complete")
